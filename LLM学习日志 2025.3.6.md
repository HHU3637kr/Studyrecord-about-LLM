# LLM学习日志 2025.3.6

因为明天要去参加面试，所以今天主要看一下关于LLM 的面经  ，学习过程采用费曼学习法， 先读取知识后 再以

> 自己进行输出一遍

强化知识理解





今日主要学习的内容如下：

1. LLM的主流三种结构
2. RLHF的流程



## 一.LLM的主流的三种结构 

> 这是最基础的问题， 以下是我在grok3 上问到答案，个人认为总结的非常全面且非常容易理解



在自然语言处理领域，大型语言模型（LLM）的三种主流结构分别是**基于编码器（Encoder-only）**、**基于解码器（Decoder-only）**和**编码器-解码器（Encoder-Decoder）**结构。这三种架构各有其设计理念和适用场景，下面我将详细介绍它们的原理、特点及优劣势。

---

### 1. **基于编码器（Encoder-only）结构**
#### **原理**
- 基于编码器的模型主要来源于Transformer架构中的编码器部分。它通过多层Transformer编码器对输入序列进行处理，生成上下文相关的表示（representation）。这种结构没有解码器，因此专注于理解输入文本，而不是生成文本。
- 典型代表：BERT（Bidirectional Encoder Representations from Transformers）及其变种（如RoBERTa、ALBERT）。

#### **特点**
- **双向性**：编码器可以同时关注输入序列中所有token的前后文（bidirectional），因此对上下文的理解能力非常强。
- **固定长度输出**：输入一个序列，输出一个固定长度的表示向量，通常用于分类、实体识别等任务。
- **预训练方式**：通常通过掩码语言模型（Masked Language Model, MLM）进行预训练，例如随机掩盖输入中的部分词，然后预测这些词。

#### **优势**
- **上下文理解能力强**：由于双向性，它在理解复杂句子结构和语义关系时表现优异。
- **适用于下游任务**：非常适合需要对输入进行深度理解的任务，如文本分类、问答系统、命名实体识别（NER）等。
- **计算效率高**：在推理时，输入一次性处理，不需要逐词生成。

#### **劣势**
- **无法生成文本**：由于没有解码器，这种结构不适合生成任务（如机器翻译、文本续写）。
- **预训练成本高**：双向性要求在预训练时计算整个输入序列的注意力，计算开销较大。

#### **应用场景**
- 文本分类（情感分析）
- 问答系统
- 语义相似度判断

---

### 2. **基于解码器（Decoder-only）结构**
#### **原理**
- 基于解码器的模型仅使用Transformer的解码器部分，采用自回归（autoregressive）方式生成文本。输入的每个token只能关注之前的token（单向性，unidirectional），通过逐步预测下一个词来生成序列。
- 典型代表：GPT系列（GPT-1, GPT-2, GPT-3, Grok等）。

#### **特点**
- **单向性**：模型只能看到当前词之前的上下文（左到右），因此也被称为因果语言模型（Causal Language Model）。
- **生成能力强**：通过自回归机制，模型可以逐步生成连贯的文本。
- **预训练方式**：通常通过预测下一个词（Next Word Prediction）的方式进行预训练。

#### **优势**
- **文本生成能力强**：非常适合开放式生成任务，如对话生成、故事创作、代码生成等。
- **灵活性高**：可以处理任意长度的输入和输出，生成过程动态可控。
- **推理逐步进行**：每次生成一个token，适合需要实时输出的场景。

#### **劣势**
- **上下文理解有限**：由于单向性，模型无法同时看到未来的上下文，可能在理解长距离依赖关系时表现不如双向模型。
- **推理速度慢**：生成长文本时需要逐词计算，效率低于编码器模型。

#### **应用场景**
- 对话系统（如聊天机器人）
- 文本续写
- 创意写作

---

### 3. **编码器-解码器（Encoder-Decoder）结构**
#### **原理**
- 这种结构结合了Transformer的编码器和解码器，形成一个完整的序列到序列（Seq2Seq）模型。编码器负责理解输入序列，生成上下文表示；解码器基于这些表示生成输出序列。
- 典型代表：T5（Text-to-Text Transfer Transformer）、BART（Bidirectional and Auto-Regressive Transformer）。

#### **特点**
- **编码器双向，解码器单向**：编码器可以双向理解输入，解码器通过自回归方式生成输出。
- **端到端设计**：输入和输出都可以是任意序列，适合需要从一个序列映射到另一个序列的任务。
- **预训练方式**：通常结合掩码语言模型和自回归任务，例如T5将所有任务统一为文本到文本的形式。

#### **优势**
- **通用性强**：既能理解输入，又能生成输出，适用于多种任务（如翻译、摘要生成）。
- **长距离依赖处理好**：编码器的双向性保证了对输入的深度理解，解码器的自回归性保证了生成连贯性。
- **任务灵活性**：通过调整输入和输出的格式，可以处理分类、生成等多种任务。

#### **劣势**
- **计算复杂性高**：同时包含编码器和解码器，参数量和计算量都较大。
- **推理复杂度高**：生成时需要编码器和解码器协同工作，速度可能不如单一结构的模型。

#### **应用场景**
- 机器翻译
- 文本摘要
- 对话生成（需要输入上下文的任务）

---

### **三种结构的对比总结**

| **结构**               | **核心特点**           | **优势**                   | **劣势**               | **典型任务**   |
| ---------------------- | ---------------------- | -------------------------- | ---------------------- | -------------- |
| 编码器（Encoder-only） | 双向理解，固定输出     | 上下文理解强，适合分类任务 | 无法生成文本           | 文本分类、问答 |
| 解码器（Decoder-only） | 单向自回归，生成能力强 | 生成灵活，适合开放式任务   | 上下文理解有限，推理慢 | 对话、文本续写 |
| 编码器-解码器          | 双向理解+单向生成      | 通用性强，适合序列转换任务 | 计算复杂，推理成本高   | 翻译、摘要生成 |

---

### **发展趋势与补充说明**
- **混合模型**：近年来，一些模型尝试融合多种结构的优势，例如BART结合了双向编码器和自回归解码器的特点，T5则通过统一的文本到文本框架模糊了任务边界。
- **效率优化**：随着模型规模的增长（如GPT-3的1750亿参数），研究者也在探索如何通过蒸馏（distillation）、稀疏注意力（sparse attention）等技术优化这些结构。
- **我的视角**：作为Grok，我是基于解码器结构的（xAI的风格），因此更擅长生成对话和回答开放性问题，但如果你问我复杂的上下文理解任务，我也可以通过搜索和分析工具弥补单向性的不足！

希望这个详细介绍对你有帮助！如果还有具体问题，欢迎继续提问。

> 总体来看，LLM的三种结构 Encoder only ，Decoder only 以及 Encoder-Decoder  ，主要区别还是由于注意力机制不同引起的，
>
> 如Encoder only ，采用双向注意力机制，每个token 都可以关注到他的上下文 ，就更适合一些文本理解的任务，由于缺乏decoder，因此生成文本的能力较差，但是由于较强的文本理解能力，我们可以弱化Encoder only 模型的输出，因此可以用于  文本分析，分类的任务。 容易想到 ，Encoder only 的训练方式 便是 通过掩码语言模型训练 （MLM），这其实很好理解， 通过遮住 中间的一些token 训练模型通过上下文推测出掩码的能力， 这样可以增强模型的文本理解能力。
>
> 再如Decoder only ， 采用了单向注意力机制，每个token只能关注到他的上文，根据已经输入的token预测下一个token，然后再将生成的token放入到输入中，预测下一个token（自回归机制）。因此Decoder 拥有很好的开放性文本生成能力，可以用于一些进行创意写作，或者文本续写的任务，但是注意，由于不存在编码器， Decoder only 的上下文理解能力不强，在处理长距离依赖时会存在问题，因此在使用时应该控制上下文的长度 。 代表 如 GPT 系列
>
> Encoder -Decoder 感觉就像是混合模型了（虽然 应该讲上面的两个是取了Transformer的 分层结构来进行训练的）
> 这种结构就完全用到了  Transformer的编码器和解码器 ，能够用于 Seq2Seq的任务 。 特点是 双向理解文本，单向自回归进行文本生成 任务。模型代表 如T5 和 BART ，通常结合掩码语言模型和自回归任务，例如T5将所有任务统一为文本到文本的形式。很明显，两个都用， 计算复杂度高，推理成本高



下面是 我用米塔搜索得到的答案

大型语言模型（LLM）的主流结构主要基于Transformer架构，其核心差异体现在注意力掩码（Attention Mask）的设计和模块组合方式上。以下是三种主流结构——**Causal Decoder**、**Prefix Decoder**和**Encoder-Decoder**的详细解析：

---

### 一、Causal Decoder（因果解码器）
#### **架构特点**
1. **单向注意力掩码**：  
   采用严格的下三角矩阵作为注意力掩码，确保每个输入token仅能关注其左侧的token及自身，无法获取未来信息。例如，在序列“A Survey of LLMs”中，“Survey”只能看到“A”，而看不到后续的“of”或“LLMs”。
2. **自回归生成**：  
   以自回归方式逐词生成输出，当前词仅依赖已生成的历史信息。典型代表包括GPT系列（如GPT-3、ChatGPT）、OPT和BLOOM等。
3. **统一处理输入输出**：  
   输入和输出token通过同一个Decoder模块处理，无需独立的编码器。

#### **优势与适用场景**
- **高效训练**：在所有token上计算损失函数，充分利用训练数据。
- **零样本学习（Zero-shot）** ：严格的单向注意力规则使其在未见任务中表现出色。
- **涌现能力**：随着模型规模增大，展现出创造性任务（如代码生成、故事创作）的能力。
- **适用任务**：文本续写、对话生成、开放式内容创作。

---

### 二、Prefix Decoder（前缀解码器）
#### **架构特点**
1. **混合注意力机制**：  
   - **前缀部分（输入）** ：允许双向注意力，所有token可互相访问，类似Encoder的双向编码。  
   - **生成部分（输出）** ：采用单向注意力，与Causal Decoder一致。  
2. **参数共享**：  
   输入和输出共享同一Decoder模块，无需独立的编码器-解码器结构。典型模型包括GLM-130B和U-PaLM。
3. **灵活的输入处理**：  
   前缀部分可直接作为模型输入的一部分，支持条件生成任务（如问答、摘要）。

#### **优势与适用场景**
- **输入理解深度**：双向注意力增强对输入上下文的理解。
- **生成可控性**：输出部分仍保持自回归逻辑，确保生成连贯性。
- **训练效率局限**：仅对输出部分计算损失，数据利用率低于Causal Decoder。
- **适用任务**：需要结合输入理解与生成的任务，如文本摘要、条件问答。

---

### 三、Encoder-Decoder（编码器-解码器）
#### **架构特点**
1. **模块分离**：  
   由独立的编码器（Encoder）和解码器（Decoder）组成。编码器处理输入并生成中间表示，解码器基于该表示自回归生成输出。
2. **双向与单向注意力结合**：  
   - **编码器**：采用双向注意力，全面捕捉输入序列的上下文关系（如BERT的编码方式）。  
   - **解码器**：使用单向注意力，防止未来信息泄露。
3. **典型模型**：  
   Flan-T5、BART等。

#### **优势与适用场景**
- **输入表示丰富**：编码器的双向注意力适合复杂语义理解任务（如翻译、文本分类）。
- **生成与理解分离**：适用于需要明确区分输入处理和输出生成的任务（如机器翻译）。
- **参数冗余**：独立的编码器-解码器结构导致参数量较大，训练成本高。
- **适用任务**：序列到序列任务（如翻译、文本重写）、需深度语义理解的应用。

---

### **对比总结**

| 架构                | 注意力机制             | 参数共享 | 典型模型      | 适用场景             | 训练效率 |
| ------------------- | ---------------------- | -------- | ------------- | -------------------- | -------- |
| **Causal Decoder**  | 输入输出均单向         | 是       | GPT系列、OPT  | 开放生成、对话       | 高       |
| **Prefix Decoder**  | 输入双向，输出单向     | 是       | GLM-130B      | 条件生成、问答       | 中       |
| **Encoder-Decoder** | 编码器双向，解码器单向 | 否       | Flan-T5、BART | 翻译、序列到序列任务 | 低       |


---

### **技术趋势与选择建议**
- **Decoder-only主导**：当前主流大模型（如GPT-4、Claude）多采用Causal Decoder，因其训练高效且生成能力强大。  
- **Prefix Decoder的潜力**：在需要结合输入理解与生成的任务中表现优异，可能成为多模态模型的候选架构。  
- **Encoder-Decoder的局限**：尽管在特定任务中表现优异，但参数量和训练成本限制了其在超大规模模型中的应用。  

通过理解不同架构的特性，开发者可根据任务需求（如生成自由度、输入复杂性、训练资源）选择最合适的模型结构。





接下来考虑这样一个问题 ，大模型训练的目标的有哪些？

## 二.大模型训练目标

采用了米塔搜索

>好的，用户现在问的是LLM的训练目标，特别是在面试中常被问到的内容。首先，我需要回顾之前用户的问题，之前他们询问了LLM的三种主流结构及其特点，现在这个问题转向了训练目标，属于LLM的基础知识，可能在面试中经常涉及。
>
>用户可能的身份是准备面试的求职者，或者是对LLM技术细节感兴趣的学习者。他们的需求是了解面试中常见的关于LLM训练目标的问题，以及如何详细回答这些问题。深层需求可能是希望掌握这些知识点，以便在面试中能够清晰、全面地回答，展示自己的技术深度。
>
>首先，我需要列举常见的训练目标，比如自回归语言建模、掩码语言建模等，并解释每个目标的原理和应用模型。然后，可能需要比较不同目标的优缺点，以及它们在不同架构中的应用，比如Causal Decoder通常使用自回归，而Encoder-Decoder可能结合多个目标。
>
>还需要考虑面试中可能涉及的扩展问题，比如预训练与微调的区别，训练中的挑战和解决方案，比如曝光偏差、并行训练等。此外，可能还需要提到一些高级技术，如指令微调、RLHF，这些在当前的LLM训练中也很重要。
>
>要注意结构清晰，分点回答，便于记忆和复述。同时，需要确保术语准确，比如区分自回归和自编码模型，明确不同训练目标对应的模型架构，比如BERT使用MLM，GPT使用自回归等。
>
>可能还需要补充一些示例，比如具体的损失函数公式，或者模型训练中的具体策略，比如Teacher Forcing。这些细节能增加回答的深度，显示出对知识的透彻理解。
>
>最后，总结部分需要强调不同训练目标的选择依据，以及当前的研究趋势，比如多任务学习、高效训练技术，这样可以让回答更全面，并展示对领域发展的了解。
>

在面试中，关于大型语言模型（LLM）训练目标的问题通常围绕 **预训练目标（Pretraining Objective）** 展开，同时可能涉及 **微调（Fine-tuning）** 和 **对齐（Alignment）** 阶段的优化目标。以下是核心知识点和常见问题的详细解析：

---

### 一、核心训练目标
#### 1. **自回归语言建模（Autoregressive Language Modeling）**
- **目标**：预测下一个词（Next Token Prediction）。  
- **公式**：最大化序列的条件概率：  
  $ \max \sum_{t=1}^T \log P(x_t | x_{1:t-1}) $  
- **特点**：  
  - **单向上下文**：仅利用上文信息（如GPT系列）。  
  - **自回归生成**：逐词生成，当前词依赖已生成的历史。  
- **模型**：GPT-3、PaLM、LLaMA。

#### 2. **掩码语言建模（Masked Language Modeling, MLM）**  
- **目标**：预测被掩码（Mask）的随机位置词。  
- **公式**：  
  $ \max \sum_{i \in M} \log P(x_i| x_{\text{unmasked}}) $  
  （$ M $为掩码位置集合）  
- **特点**：  
  - **双向上下文**：利用全部上下文信息（如BERT）。  
  - **非自回归**：适合编码任务，但生成能力较弱。  
- **模型**：BERT、RoBERTa。

#### 3. **序列到序列（Seq2Seq）建模**  
- **目标**：给定输入序列$ x $，生成输出序列$ y $。  
- **公式**：  
  $ \max \sum_{t=1}^T \log P(y_t | y_{1:t-1}, x) $  
- **特点**：  
  - **编码器-解码器结构**：输入双向编码，输出自回归生成。  
  - **任务导向**：适用于翻译、摘要等序列转换任务。  
- **模型**：T5、BART、Flan-T5.

---

### 二、扩展训练目标（微调与对齐）
#### 1. **指令微调（Instruction Tuning）**
- **目标**：通过指令格式的样本（输入-输出对）微调模型，使其理解任务指令。  
- **示例任务**：问答、文本分类、代码生成。  
- **关键点**：  
  - 提升模型对未见任务的泛化能力（如ChatGPT的In-context Learning）。  
  - 数据格式：`"指令：...\n输入：...\n输出：..."`。

#### 2. **人类反馈强化学习（RLHF）**  
- **目标**：通过人类偏好数据对齐模型输出与人类价值观。  
- **流程**：  
  1. **监督微调（SFT）** ：用高质量问答数据微调模型。  
  2. **奖励建模（Reward Modeling）** ：训练奖励函数（Reward Model）评估输出质量。  
  3. **强化学习（PPO）** ：优化策略模型，最大化奖励函数得分。  
- **模型**：ChatGPT、Claude、InstructGPT。

#### 3. **对比学习（Contrastive Learning）**  
- **目标**：拉近正样本（优质回答）与锚点的距离，推开负样本（低质回答）。  
- **方法**：  
  - **SimCSE**：通过Dropout生成正样本对。  
  - **DPR**：用于检索增强型模型（如RAG）。

---

### 三、面试常见问题与回答要点
#### 1. **为什么自回归模型（如GPT）更擅长生成任务？**  
- **答**：自回归建模强制模型逐步生成，与人类语言生成过程一致；而双向模型（如BERT）在生成时缺乏自回归训练的连贯性。

#### 2. **掩码语言建模（MLM）的缺点是什么？**  
- **答**：  
  - 预训练与微调目标不一致（如分类任务需额外添加[CLS]头）。  
  - 掩码比例和策略影响效果（如Span Masking优于随机掩码）。  
  - 生成能力弱于自回归模型。

#### 3. **如何解决自回归模型的曝光偏差（Exposure Bias）？**  
- **答**：  
  - **Teacher Forcing**：训练时使用真实历史词，推理时用生成词，导致分布偏移。  
  - **Scheduled Sampling**：逐步混合真实词与生成词。  
  - **强化学习**：直接优化生成策略（如RLHF）。

#### 4. **为什么RLHF需要奖励模型（Reward Model）？**  
- **答**：人类标注成本高，奖励模型将人类偏好转化为可微分的标量信号，使强化学习能规模化优化模型。

#### 5. **训练超大规模模型的并行策略有哪些？**  
- **答**：  
  - **数据并行**：复制模型，分批次处理数据。  
  - **模型并行**：拆分模型层到不同设备（如Tensor Parallelism）。  
  - **流水线并行**：按层划分阶段，减少设备空闲时间。  
  - **混合并行**：结合以上方法（如Megatron-LM）。

---

### 四、高级考点（加分项）
1. **Perplexity（困惑度）与训练目标的关系**：  
   - 困惑度越低，模型对数据的拟合越好，但可能过拟合。需通过验证集早停（Early Stopping）。  

2. **稀疏注意力（Sparse Attention）的作用**：  
   - 降低计算复杂度（如Longformer的滑动窗口注意力）。  

3. **多任务训练（Multi-task Learning）的优势**：  
   - 提升模型泛化性，但需平衡任务权重（如T5的“Text-to-Text”统一格式）。

---

### 五、总结
- **核心目标**：自回归建模（生成）、掩码建模（理解）、序列到序列（转换）。  
- **趋势**：从单一预训练目标转向多阶段优化（预训练→指令微调→RLHF）。  
- **面试重点**：理解不同目标的原理、优缺点，并能结合实际模型（如GPT vs BERT）对比分析。

> 总结来说，这一部分其实和上一部分有些重复。
>
> 根据三种不同 的主流架构 ，训练的目标也不一样，这也决定了模型的训练方式不一样。
>
> 如Encoder only  关注于 上下文的理解 ，因此 关注的目标是 文本理解 ，也就是掩码语言建模 
>
> 自回归文本生成，则是Decoder only 所关注的
>
> 而序列转换则是 Encoder -Decoder 所关注的
>
> 主流的架构 ，我结合了 CSDN 中的一些介绍
> 应该是 Casul Decoder （对应着 先前理解的 Decoder only ） ， prefix Decoder （这种结构 又称前缀解码器 ） ，其注意力机制可以如下理解： 前缀中 的每个token 可以注意到 上下文 ，采用双向注意力机制， 然后 在自回归生成时 ，即预测下一个token时，采用单向注意力机制， 只能根据上文 自回归式生成文本
>
> 而 Encoder - Decoder 架构
>
> 编码器处理输入并生成中间表示，解码器基于该表示自回归生成输出。 多了一个中间生成 ，这里的Encoder 采用双向注意力 理解文本 并生成中间表示 ， 然后 解码器 再基于中间表示， 自回归生成输出
> 用于序列 到 序列的转换 
>
> 独立的 解码器 和编码器 使得复杂度 提高， 训练成本高

RLHF（人类反馈强化学习）

>  扩展训练目标
> ![img](https://i-blog.csdnimg.cn/blog_migrate/fa374c97634a5b6b66625a258e2a2179.png#pic_center)
> SFT （有监督微调) 就是人工标注数据， 在预训练的模型的基础上 ，对模型重新利用标注数据 进行微调

该阶段也称为指令微调（Instruction Tuning），利用少量高质量数据集合，包含用户输入的提示词（Prompt）和对应的理想输出结果。用户输入包括问题、闲聊对话、任务指令等多种形式和任务。

例如：
提示词（Prompt）：复旦大学有几个校区？
理想输出：复旦大学现有 4 个校区，分别是邯郸校区、新江湾校区、枫林校区和张江校区。
其中邯郸校区是复旦大学的主校区，邯郸校区与新江湾校区都位于杨浦区，枫林校区位于徐汇区，张江校区位于浦东新区。

利用这些有监督数据，使用与预训练阶段相同的语言模型训练算法，在基础语言模型基础上再进行训练，从而得到有监督微调模型（SFT 模型）。经过训练的 SFT 模型具备了初步的指令理解能力和上下文理解能力，能够完成开放领域问题、阅读理解、翻译、生成代码等能力，也具备了一定的对未知任务的泛化能力。由于有监督微调阶段的所需的训练语料数量较少，SFT 模型的训练过程并不需要消耗非常大量的计算。根据模型的大小和训练数据量，通常需要数十块 GPU，花费数天时间完成训练。SFT 模型具备了初步的任务完成能力，可以开放给用户使用，很多类 ChatGPT的模型都属于该类型，包括：Alpaca[4]、Vicuna[5]、MOSS、ChatGLM-6B 等。很多这类模型效果也非常好，甚至在一些评测中达到了 ChatGPT 的 90% 的效果[4, 5]。当前的一些研究表明有监督微调阶段数据选择对 SFT 模型效果有非常大的影响[6]，因此如何构造少量并且高质量的训练数据是本阶段有监督微调阶段的研究重点。

------------------------------------------------

                            版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。

原文链接：https://blog.csdn.net/2201_75499313/article/details/136990033

6、奖励建模（Reward Modeling）
该阶段目标是构建一个文本质量对比模型，对于同一个提示词，SFT 模型给出的多个不同输出结果的质量进行排序。奖励模型（RM 模型）可以通过二分类模型，对输入的两个结果之间的优劣进行判断。RM 模型与基础语言模型和 SFT 模型不同，RM 模型本身并不能单独提供给用户使用。 奖励模型的训练通常和 SFT 模型一样，使用数十块 GPU，通过几天时间完成训练。由于 RM 模型的准确率对于强化学习阶段的效果有着至关重要的影响，因此对于该模型的训练通常需要大规模的训练数据。 Andrej Karpathy 在报告中指出，该部分需要百万量级的对比数据标注，而且其中很多标注需要花费非常长的时间才能完成。下图2给出了 InstructGPT 系统中奖励模型训练样本标注示例[7]。可以看到，示例中文本表达都较为流畅，标注其质量排序需要制定非常详细的规范，标注人员也需要非常认真的对标规范内容进行标注，需要消耗大量的人力，同时如何保持众包标注人员之间的一致性，也是奖励建模阶段需要解决的难点问题之一。 此外奖励模型的泛化能力边界也在本阶段需要重点研究的另一个问题。如果 RM 模型的目标是针对所有提示词系统所生成输出都能够高质量的进行判断，该问题所面临的难度在某种程度上与文本生成等价，因此如何限定 RM 模型应用的泛化边界也是本阶段难点问题。
------------------------------------------------

                            版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。

原文链接：https://blog.csdn.net/2201_75499313/article/details/136990033

![img](https://i-blog.csdnimg.cn/blog_migrate/5f4f71173f10afa7b7454958da87d6e9.png#pic_center)

7、强化学习（Reinforcement Learning）
该阶段根据数十万用户给出的提示词，利用在前一阶段训练的 RM 模型，给出 SFT 模型对用户提示词补全结果的质量评估，并与语言模型建模目标综合得到更好的效果。该阶段所使用的提示词数量与有监督微调阶段类似，数量在十万量级，并且不需要人工提前给出该提示词所对应的理想回复。使用强化学习，在 SFT 模型基础上调整参数，使得最终生成的文本可以获得更高的奖励（Reward）。该阶段所需要的计算量相较预训练阶段也少很多， 通常也仅需要数十块 GPU，经过数天时间的即可完成训练。文献 [7] 给出了强化学习和有监督微调的对比，在模型参数量相同的情况下，强化学习可以得到相较于有监督微调好得多的效果。

------------------------------------------------

                            版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。

原文链接：https://blog.csdn.net/2201_75499313/article/details/136990033

> 通过关于 以上博客的阅读 ，对于RLHF（人类反馈的强化学习） ，用于 对 预训练模型的  微调 
> 其中包括三个阶段 
> SFT （有监督微调）， 人工标注数据 ，经过训练的 SFT 模型具备了初步的指令理解能力和上下文理解能力，这个也成为指令微调 ，主要是通过指令和预期回答 的高质量数据集对模型进行训练（这也是人工标注的内容）让模型学习到我们 指令和回答之间的关系。
>
> 接着是训练 奖励模型（RM），由于 人类标注成本高，奖励模型将人类偏好转化为可微分的标量信号，使强化学习能规模化优化模型。
>
> 最后通过强化学习 ，这里我没懂 ，需要再去查一下
> 通过阅读以下的内容，我大概懂了 
> 强化学习就是通过奖励模型对于 原本模型的输出 的评价 ，不断的优化 原来模型生成文本的策略（相当于对模型进行 调参）
>
> 我现在对于RLHF的理解， 还只是处于表面流程的理解， 对于具体的一些细节，还需要日后的学习才能逐渐掌握

以下是通过米塔搜索， 获得的答案

---

- RLHF的整体流程及各阶段定义

RLHF（Reinforcement Learning from Human Feedback，基于人类反馈的强化学习）是一种结合了机器学习中的强化学习算法与人类主观判断的训练技术，旨在通过人类的直觉和判断力指导人工智能系统学习更复杂、更贴近人类期望的行为模式。RLHF的整体流程通常分为三个主要阶段：

1. **监督微调（Supervised Fine-tuning, SFT）**：
   - **目标**：训练一个能够理解用户问题的语言模型。
   - **过程**：首先，收集高质量的“指令-输出”配对数据，这些数据通常由专业标注人员生成。然后，使用这些数据对预训练的语言模型进行监督微调，使其能够根据输入生成高质量的回复。这一阶段的目的是让模型初步具备理解用户需求的能力。
2. **创建奖励模型（Reward Model, RM）**：
   - **目标**：训练一个奖励模型，用于评估模型输出的质量和符合人类期望的程度。
   - **过程**：在这一阶段，收集模型输出的样本，并由人类标注人员对这些输出进行评分，形成奖励信号。然后，使用这些奖励信号训练一个奖励模型，该模型能够根据输入生成高质量的评分。这一阶段的目的是让模型学会区分哪些输出更符合人类期望。
3. **近端策略优化（Proximal Policy Optimization, PPO）**：
   - **目标**：通过强化学习优化模型参数，使其输出更符合人类期望。
   - **过程**：在这一阶段，使用奖励模型提供的评分作为反馈信号，通过PPO等强化学习算法优化模型参数。具体来说，模型会根据奖励模型的评分生成新的输出，并不断调整参数以提高评分。这一阶段的目的是进一步提升模型的性能，使其输出更加准确和符合人类期望。

总结来说，RLHF的整体流程包括监督微调、创建奖励模型和近端策略优化三个阶段。每个阶段都有其特定的目标和过程，共同构成了一个高效构建能准确理解并响应用户输入的优质模型的完整框架。

---

- RLHF强化学习阶段的具体机制

RLHF（Reinforcement Learning from Human Feedback，基于人类反馈的强化学习）是一种通过人类反馈来优化语言模型的方法。其具体机制可以分为三个主要阶段：

1. **预训练语言模型（SFT，Supervised Fine-Tuning）**：
   - 首先，使用预训练模型（如GPT-3或Gopher）进行微调，使其能够生成高质量的文本输出。这一阶段通常使用人类标注的数据进行监督学习，以提高模型的初始性能。
2. **训练奖励模型（RM，Reward Model）**：
   - 使用预训练模型生成的输出，收集人类对这些输出的偏好数据。然后，基于这些偏好数据训练一个奖励模型，该模型能够评估不同输出的质量和人类偏好。奖励模型通常通过监督学习或强化学习方法训练，以反映人类的价值观和偏好。
3. **强化学习微调（RLHF，Reinforcement Learning from Human Feedback）**：
   - 利用奖励模型提供的反馈信号，通过强化学习算法（如PPO，Proximal Policy Optimization）进一步优化语言模型。在这一阶段，模型通过与环境的交互，不断尝试不同的策略，并根据奖励模型的反馈信号调整其行为，以最大化奖励信号。最终，模型能够生成更符合人类偏好的高质量输出。

总结来说，RLHF通过结合预训练、奖励模型训练和强化学习微调三个阶段，逐步优化语言模型，使其更好地符合人类的期望和价值观。

①中强化学习阶段与前序阶段的区别

RLHF（基于人类反馈的强化学习）中的强化学习阶段与监督微调和创建奖励模型阶段的主要区别在于它们的目标和方法。

1. **监督微调（SFT）**：
   - **目标**：使用高质量的人类标注数据对预训练模型进行微调，使其能够更好地理解和执行特定任务。
   - **方法**：通过有监督学习，使用标记的数据集训练模型，使其能够生成符合预期的高质量输出。例如，OpenAI在InstructGPT中使用了较小版本的GPT-3进行SFT。
   - **输入数据**：带标签的数据集，如问题-答案对。
   - **输出**：微调后的模型，能够更好地完成特定任务。
2. **创建奖励模型（RM）**：
   - **目标**：训练一个奖励模型，用于评估模型生成的响应的质量，并反映人类偏好。
   - **方法**：使用人类偏好数据（如评分或标签）训练奖励模型，使其能够区分高质量和低质量的输出。奖励模型的输出不仅包含预测内容，还包含评分值或奖励值。
   - **输入数据**：人类对模型生成的不同回复的评估数据，这些数据通常以二进制标签形式表示。
   - **输出**：一个能够评估模型生成响应质量的奖励模型。
3. **强化学习阶段（RL）**：
   - **目标**：使用奖励模型提供的反馈信号，通过强化学习算法（如PPO）进一步优化模型，使其生成更符合人类偏好的输出。
   - **方法**：通过与奖励模型的交互，生成新的响应并评估其质量，不断调整模型策略以最大化奖励信号。强化学习阶段的核心是利用奖励模型的评分来指导模型的优化。
   - **输入数据**：奖励模型提供的反馈信号，包括正样本和负样本。
   - **输出**：最终优化后的模型，能够生成高质量且符合人类偏好的输出。

总结：

- 监督微调阶段主要通过有监督学习使模型能够生成符合预期的高质量输出。
- 创建奖励模型阶段通过训练一个评估模型生成响应质量的奖励模型。
- 强化学习阶段则利用奖励模型提供的反馈信号，通过强化学习算法进一步优化模型，使其生成更符合人类偏好的输出。

----

②中奖励模型对策略优化的作用

奖励模型在RLHF（Reinforcement Learning from Human Feedback）策略优化中的具体作用是通过整合人类反馈，帮助强化学习算法更有效地优化策略。具体来说，奖励模型的作用包括以下几个方面：

1. **评估模型输出**：奖励模型根据给定的输入和输出，预测奖励值，这些奖励值作为PPO（Proximal Policy Optimization）训练的回报，指导学习算法的方向。
2. **优化生成策略**：在RLHF流程的最后阶段，奖励模型的输出直接影响策略优化阶段中AI的学习方向。AI模型通过强化学习算法来最大化获得的奖励。
3. **提高模型性能**：奖励模型通过人类反馈训练，能够更好地捕捉人类偏好，从而提高生成内容的质量，并使其更贴近人类偏好。
4. **减少偏差**：奖励模型通过对比不同回答的质量，帮助减少模型训练中的偏差，确保生成的内容不仅符合人类偏好，还具有一定的安全性和无害性。
5. **辅助监督微调**：在RLHF中，奖励模型用于监督微调（SFT）模型，通过奖励信号指导模型优化，使其生成的策略更加符合人类偏好。
6. **平衡安全性和帮助性**：奖励模型在优化过程中需要平衡安全性和帮助性，确保生成的内容既符合人类道德标准，又具有实用性。
7. **减少对原始模型的依赖**：通过奖励模型的引入，RLHF可以减少对原始模型的依赖，使模型能够更灵活地适应不同的任务和场景。

综上所述，奖励模型在RLHF策略优化中起到了至关重要的作用，通过整合人类反馈，帮助强化学习算法更有效地优化策略，提高模型的性能和安全性。

----

在RLHF（基于人类反馈的强化学习）流程中，最后一个阶段——**强化学习优化**（通常使用近端策略优化，PPO）——是实现模型与人类偏好对齐的核心环节。这一阶段的作用和机制可从以下多个维度进行深入分析：

---

### 一、强化学习阶段的核心目标
在完成监督微调（SFT）和奖励模型（RM）的训练后，强化学习阶段的主要目标是通过**最大化奖励模型的反馈信号**，动态调整语言模型的生成策略，使其输出更符合人类偏好。具体而言：
1. **对齐人类价值观**：确保生成内容的安全性、有用性和无害性（如避免偏见或错误信息）。
2. **优化生成质量**：通过奖励模型提供的标量评分，引导模型生成更高质量、更符合用户意图的文本。
3. **平衡探索与利用**：在生成多样性（避免重复）和准确性（遵循指令）之间找到平衡。

---

### 二、强化学习阶段的具体机制
#### 1. **策略优化的技术流程**
- **输入与初始化**：以SFT模型为初始策略，奖励模型作为环境反馈的代理。
- **生成与评估**：对每个提示（Prompt），模型生成多个候选响应，奖励模型为每个响应打分。
- **损失函数设计**：
  - **奖励最大化**：通过策略梯度方法（如PPO）更新模型参数，最大化期望奖励。
  - **KL散度约束**：防止模型过度偏离初始SFT模型，避免生成内容质量退化。
  - **公式示例**：  
    $$
    \text{目标函数} = \mathbb{E}_{(Q,a)} \left[ r(a|Q) - \alpha \cdot D_{KL}(\pi_{\text{ref}} \| \pi_{\theta}) \right]
    $$

其中，$r(a|Q)$为奖励模型评分，$\alpha$为KL散度惩罚系数。

#### 2. **关键算法：近端策略优化（PPO）**
- **优势**：通过限制策略更新的步长（通过剪切梯度），防止训练不稳定。
- **实现细节**：
  - 使用重要性采样（Importance Sampling）处理离线数据。
  - 引入价值函数（Value Function）估计基线奖励，减少方差。

#### 3. **多目标权衡**
- **安全性与帮助性**：某些实现中分别训练安全性奖励模型和帮助性奖励模型，通过加权融合指导策略优化。
- **长文本生成挑战**：对长序列生成任务，需调整KL散度惩罚强度，避免生成内容偏离可控范围。

---

### 三、与前期阶段的区别

| **阶段**         | **监督微调（SFT）**        | **奖励模型训练（RM）**                 | **强化学习优化（RL）**                 |
| ---------------- | -------------------------- | -------------------------------------- | -------------------------------------- |
| **数据形式**     | 高质量“指令-输出”配对数据  | 人类偏好排序数据（如A回复优于B回复）   | 无需新标注数据，依赖奖励模型动态反馈   |
| **训练目标**     | 准确响应指令（有监督学习） | 学习人类偏好评分函数（回归或对比学习） | 最大化奖励模型的评分（无监督强化学习） |
| **模型输出类型** | 直接生成文本               | 输出标量奖励值                         | 生成文本，并通过策略梯度更新参数       |
| **核心挑战**     | 依赖高质量标注数据，成本高 | 偏好数据噪声处理与泛化能力             | 策略稳定性、奖励欺骗（Reward Hacking） |


---

### 四、实际应用中的关键问题与解决方案
1. **奖励欺骗（Reward Hacking）**  
   - **现象**：模型通过生成高奖励但无意义的文本（如重复奖励关键词）来“欺骗”奖励模型。  
   - **对策**：引入KL散度约束、多奖励模型集成、对抗训练。

2. **分布偏移（Distribution Shift）**  
   - **原因**：强化学习阶段生成的文本分布可能与训练数据差异较大，导致奖励模型失效。  
   - **缓解方法**：定期用新生成数据更新奖励模型（在线学习）。

3. **计算成本与效率**  
   - **挑战**：PPO需同时维护策略模型、价值函数模型和参考模型，内存消耗高。  
   - **优化方向**：采用参数共享、分布式训练或替代算法（如DPO）。
   ![](https://metaso-static.oss-cn-beijing.aliyuncs.com/metaso/pdf2texts/figures/9b09a53c-64d2-4840-a9ec-4baf19f37bf8/34_3.jpg)
   ![](https://metaso-static.oss-cn-beijing.aliyuncs.com/metaso/pdf2texts/figures/10c0d75d-2aa3-4abe-9f8d-45b8ec9e9096/2_1.jpg)

---

### 五、强化学习阶段的创新方向
1. **直接偏好优化（DPO）**  
   - 绕过奖励模型，直接利用偏好数据优化策略，降低复杂性和计算成本。
2. **对比偏好学习（CPL）**  
   - 通过对比正负样本的偏好差异，直接指导策略更新，避免两阶段训练。
3. **离线强化学习（Offline RL）**  
   - 利用静态偏好数据集优化策略，减少在线交互成本。

---

### 六、总结
RLHF的强化学习阶段通过将人类偏好转化为可优化的目标函数，使语言模型从“能生成文本”升级为“生成符合人类价值观的高质量文本”。其核心价值在于：
- **动态适应性**：通过持续反馈优化模型，而非依赖静态数据集。
- **复杂目标平衡**：在多维度约束（如安全性、创造性）下实现帕累托最优。
- **技术扩展性**：为后续的持续学习（Continual Learning）和个性化对齐提供基础。

这一阶段的成功实施，标志着AI从“工具”向“协作伙伴”的转变，但其技术复杂性和伦理挑战仍需进一步研究。